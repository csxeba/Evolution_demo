"""
Copyright (c) 2015 GÃ³r Csaba

This program is governed by the GPL 3 license and is thus free software:
you can redistribute it and/or modify it under the terms of the GNU
General Public License as published by the Free Software Foundation.

    This program is distributed WITHOUT ANY WARRANTY; without even the
    implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
    PURPOSE.

See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>..
"""

"""
Simple Genetic Algorithm from the perspective of a Biologist.

The Population class represents a population of individuals, each with a
unique genome.
A genome consists of a pair of lists, each containing a fixed number of
integers, like [200, 200, 200]. Each number represents a genetic
allele. Each position represents a genetic locus. The aim of this particular
algorithm is to evolve a fixed 3-array of integers, the "target".
"""

# Default libraries
import math
import random
import time

# sub-modules
from Biometrics import describe as desc

# Setting hyperparameters -> can be overriden at pop initialization time
SELECTION_TARGET = [100, 100, 100]  # Individuals evolve in this direction
REPRODUCTION_TARGET = [255, 0, 255]  # This represents sexual preference
REPRODUCERS = 40  # The percent of individuals who reproduce (the bests)
DIERS = 20  # The percent of individuals who die in each epoch
DIERS_INCR = .5  # The rate by which we incr DIERS if pop size exceeds max
DIERS_DECR = 5  # The rate by which we decr DIERS after each epoch
CROSSING_OVER = 10  # The chance of a crossing over given in percentage
MUTATION = 5  # The chance of a mutation given in percentage
OFFSPRING_RNG = (1, 4)  # The number of offsprings generated by mating


class Population:
    """Abstract model of a biological population"""

    def __init__(self, limit,
                 sTarget=SELECTION_TARGET,
                 rTarget=REPRODUCTION_TARGET,
                 reproducers=REPRODUCERS,
                 diers=DIERS,
                 diers_incr=DIERS_INCR,
                 diers_decr=DIERS_DECR,
                 crossing_over=CROSSING_OVER,
                 mutation=MUTATION,
                 offspring_rng=OFFSPRING_RNG
                 ):

        self.limit = limit
        self.sTarget = sTarget
        self.rTarget = rTarget
        self.reproducers_perc = reproducers
        self.diers_perc = diers
        self.diers_incr_rate = diers_incr
        self.diers_decr_rate = diers_decr
        self.crossing_over_rate = crossing_over
        self.mutation_rate = mutation
        self.offspring_rng = offspring_rng
        self.fitness_by_gene = True

        # Generate a random number of individuals with random genomes
        self.individuals = [
            Individual(chromosomeA=random_chromosome(),
                       chromosomeB=random_chromosome())
            for _ in range(random.randrange(int(limit / 10), limit))]

        self.init_gene_pool = set([tuple(x.chromosomeA) for x in self.individuals] + \
                                  [tuple(x.chromosomeB) for x in self.individuals])

    def fitness(self):
        "Calculates an average fitness value for the whole population"
        fitnesses = [desc.avgDistance(ind, self) for ind in self.individuals]
        return round(sum(fitnesses) / len(fitnesses), 2)

    def selection(self, verbose):
        "This method mimics natural selection by disposing of a set of individuals"
        percentage_diing = self.diers_perc

        size = len(self.individuals)
        fitnesses = sorted([ind.fitness(self.sTarget) for ind in self.individuals])

        # Calculating the number of disposed individuals
        num_of_diers = (int(size * (percentage_diing / 100)))
        # Defining fitness treshold, below which every individual is selected out
        fitness_treshold = fitnesses[-num_of_diers]

        # Put the actual diing individuals into a list
        diers = [ind for ind in self.individuals
                 if ind.fitness(self.sTarget) >= fitness_treshold]

        # This is neccessary because of rounding errors
        diers = diers[:num_of_diers]

        # Generate the new list of individuals
        for dier in diers:
            self.individuals.remove(dier)

    def reproduction(self, verbose):
        "This method generates new individuals by mating existing ones"
        percentage_reproducing = self.reproducers_perc

        size = len(self.individuals)
        fitnesses = sorted([ind.fitness(self.rTarget) for ind in self.individuals])
        # Calculating the number of reproducing individuals and the fitness
        # treshold, above which every individual is participating in reproduction
        num_of_reproducers = \
            int(size * (percentage_reproducing / 100))
        fitness_treshold = fitnesses[num_of_reproducers - 1]

        # Put the actual reproducing individuals into a list
        reproducers = [ind for ind in self.individuals
                       if ind.fitness(self.rTarget) <= fitness_treshold]

        # This is neccessary because of rounding errors
        if len(reproducers) > num_of_reproducers:
            reproducers = reproducers[:num_of_reproducers]

        while len(reproducers) > 1:
            # Randomly choose 2 individuals, remove them from the list of
            # reproducers and append their offspring to the population
            indA, indB = choose(reproducers, num=2)
            offsprings = indA.reproduce(indB, self.offspring_rng)
            self.individuals = self.individuals + offsprings

    def run(self, epochs, verbose, log=False, queue=None):
        "Runs a given number of epochs: a reproduction followed by a selection"
        start = time.time()

        if verbose: print("RUN START")

        # These are used to hold some descriptors to analyze the run
        fitnesses = []
        bests = []
        heterozyg = []
        sizes = []
        mutants = []

        for epoch in range(1, epochs + 1):
            # 0. step: generate mutations at a rate given by MUTATIONS
            mutation(self)

            # 1. step: generate new individuals
            self.reproduction(verbose=verbose)

            # 2. step: dispose of a given percent of low fitness individuals
            self.selection(verbose=verbose)

            # log some descriptors (100 values each)
            if epoch % math.ceil(epochs / 100) == 0:
                fitnesses.append(self.fitness())
                bests.append(desc.best(self))
                heterozyg.append(desc.heterozygosity(self))
                sizes.append(len(self.individuals))
                mutants.append(desc.mutants(self))

            while len(self.individuals) >= self.limit:
                self.diers_perc = self.diers_perc * \
                                  (1 + self.diers_incr_rate)
                if verbose > 3:
                    print("Too many individuals, adjusting selection pressure\t{}"
                          .format(round(self.diers_perc, 2)))
                self.selection(verbose)

            self.diers_perc = self.diers_perc * \
                              (1 - self.diers_decr_rate)

            # Print out some useful information
            if (verbose >= 2) and (epoch % int(epochs / 10) == 0):
                print("Epoch " + str(epoch) + " done! Avg fitness:",
                      self.fitness(), sep="\t")
                print("\t\tSize:\t", len(self.individuals), sep="\t")

        if verbose:
            print("\n-------------------------------")
            print("Run finished. Epochs:", epoch)
            print("This took", round(time.time() - start, 2), "seconds!")

            print("\n")

        # return the logs
        logs = fitnesses, bests, sizes, mutants, heterozyg
        if log and not queue:
            return logs
        elif log and queue:
            queue.put(self, logs)


class Individual:
    """
    Abstraction of an individual inside a population
    """

    def __init__(self, chromosomeA, chromosomeB):
        self.genome = chromosomeA, chromosomeB
        self.chromosomeA = chromosomeA
        self.chromosomeB = chromosomeB
        self.phenotype = None
        self.update_phenotype()
        self.mutant = False

    def fitness(self, target, by_gene=True):
        "Fitness shows the difference between the target and the individual"
        if by_gene:
            f1 = desc.distance(self.chromosomeA, target)
            f2 = desc.distance(self.chromosomeB, target)
            return ((f1 + f2) / 2)
        else:
            return desc.distance(self.phenotype, target)

    def reproduce(self, partner, rng):
        "Mate this individual with another"
        # Checking whether crossing over occures or not
        # For description see the method <crossing_over>
        offsprings = []
        for _ in range(random.randrange(*rng)):
            if random.random() <= CROSSING_OVER:
                gametesSelf = crossing_over(*self.genome)
                gametesPartner = crossing_over(*partner.genome)
            else:
                gametesSelf = self.genome
                gametesPartner = partner.genome

            # The offspring's genome is given by randomly selecting a gene from
            # one of the parents' genome at every locus.
            newChromosomeA = random.choice((gametesSelf[0], gametesPartner[0]))
            newChromosomeB = random.choice((gametesSelf[1], gametesPartner[1]))

            offsprings.append(Individual(newChromosomeA, newChromosomeB))

        return offsprings

    def update_phenotype(self):
        self.phenotype = [int((a + b) / 2) for a, b in zip(self.chromosomeA,
                                                           self.chromosomeB)]

    def __str__(self):
        # The individual can be printed out in a nicely formatted way
        return str(self.chromosomeA) + "\n" + str(self.chromosomeB)


def crossing_over(chromosome1, chromosome2):
    # Crossing over works similarily to the biological crossing over
    # A point is selected randomly along the loci of the chromosomes,
    # excluding position 0 and the last position (after the last locus).
    # Whether the "head" or "tail" of the chromosome gets swapped is randomized
    position = random.randrange(len(chromosome1) - 2) + 1
    if random.random() >= 0.5:
        return (chromosome1[:position] + chromosome2[position:],
                chromosome2[:position] + chromosome1[position:])
    else:
        return (chromosome2[:position] + chromosome1[position:],
                chromosome1[:position] + chromosome2[position:])


def mutation(pop):
    "Generate mutations in the given population. Rate is given by <MUTATION>"

    mutants = []

    # All the loci in the population
    # number_of_individuals * number_of_chromosomes * number_of_loci
    all_loci = len(pop.individuals) * \
               len(pop.individuals[0].genome) * \
               len(pop.individuals[0].chromosomeA)

    # Mutation rate is applied to loci and not individuals!
    for _ in range(all_loci):
        if random.random() < (pop.mutation_rate / 100):
            # We generate the "coordinate" of a locus
            indN = random.randrange(len(pop.individuals))
            chrN = random.randrange(2)
            locN = random.randrange(3)
            mutants.append((indN, chrN, locN))

    for mutant in mutants:
        # [0] is the individuals number
        # [1] is the chromosome of the individual
        # [2] is the locus on the chromosome
        pop.individuals[mutant[0]].genome[mutant[1]][mutant[2]] = \
            random.randrange(start=0, stop=256)
        pop.individuals[mutant[0]].mutant = True
        pop.individuals[mutant[0]].update_phenotype()


def random_chromosome():
    "Generate a random chromosome"
    return [random.randrange(0, 256) for _ in range(3)]


def choose(iterable, num=1):
    "Choose an element randomly from an iterable and remove the element"
    out = []
    for x in range(num):
        out.append(random.choice(iterable))
        iterable.remove(out[-1])
    return out


def demo():
    logs = []
    p = Population(1000)
    # fitnesses, bests, heterozyg, sizes, mutants
    logs.append(p.run(1000, verbose=3, log=True))
    desc.describe(p, 0)
    print("\nExperiment is over.")
    print("fitnesses, bests, sizes, mutants and heterozyg are stored in logs")

    return logs


def save(pop, flpath="autosave.pop"):
    import pickle
    fl = open(flpath, mode="wb")
    pickle.dump(pop, fl)


def load(flpath="autosave.pop"):
    import pickle
    fl = open(flpath, mode="rb")
    return pickle.load(fl)


"""
TODO:
- mpRun is not working properly, but I don't care...
- Remake the GUI to be prettier and to display descriptors.
- Create buttons for alternative workflow, like "reproduction", "selection",
"+10 epoch", "mutation", "+10 individuals", etc
"""
